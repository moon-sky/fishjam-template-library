TODO: 
  1.写 CComBSTR/CComVariant 的UT
  2.通过类型库进行ComDetect?
  3.CComPtr<IShellBrowser>  spShellBrowser; 比较 if (NULL == spShellBrowser) if(spShellBrowser == NULL) 的区别
    据说不能编译，但VC2008中OK
  4.查聚合相关的源码和Demo程序 -- m_pUnkOuter、CComObjectRootBase::OuterAddRef 等，

说明性编译标示符(declspec, declarative specifier), 如 struct __declspec(uuid("xxxxxx")) IUnknown {...};
  然后可以使用 __uuidof 操作符来得到一个类型的UUID

BitBlt 的 CAPTUREBLT

C运行时本地语言设置(runtime locale setting) -- 如 wcscmp 缺省时仅比较52个不带重音的字母字符，
  要想使用操作系统的本地设置来比较字符串，必须调用 setlocale(LC_ALL, "");

C++语言定义bool数据类型是一个8位的值(0或者1)， BOOL 是long(32/64位)的

CComPtr<T>::Release 采用将指针成员变量赋值到一个临时变量中，并把成员变量重置为NULL后，才使用临时变量释放接口指针，
  这个方法避免了只能指针保存的接口可能被释放两次的问题（两个智能指针互相有引用，Release中释放时造成对方析构，
  反向调用本指针的析构，析构中会检测成员变量是否为NULL，如非NULL则可能重复释放）
  CComPtr<T>::operator->() 操作符返回 _NoAddRefReleaseOnCComPtr 模板类，禁止(编译错误)直接使用指针成员变量的 AddRef/Release
  SetSite -- 把内部指针引用的对象与一个site对象(参数punkParent)联系起来，只能指针必须指向一个实现了 IObjectWithSite 接口的对象
  Advise(Sink) -- 把一个连接点接收器对象与智能接口指针引用的对象(事件源对象)联系起来
  
CComDispatchDriver -- 是IDispatch接口的智能指针(typedef CComQIPtr<IDispatch>)，可获取和设置对象的属性
  CComDispatchDriver pDisp = XXX; pDisp->GetProperty(DISPID_COUNT, &var);
    GetIDOfName -- 可以根据属性名字的字符串获得属性的DISPID
    GetProperty/PutProperty -- 获取或设置属性的值
    GetPropertyByName/PutPropertyByName -- 根据属性名字来获取或设置属性值
    InvokeN -- 提供了多个重载的方法，方便对Invoke的调用
    
全局变量：
  _pModule(在 CComModule::Init 中初始化) 变量，就不需要再定义 ftlWindow.h 中的 ATL对象了 ?
  _AtlBaseModule
  
字符类型(ANSI/Unicode) + 字符集()
  ANSI(也称为 SBCS -- Single-Byte Character Set)
  UNICODE
  EBCDIC(Extended Binary Coded Decimal Interchange Code) -- IBM推出的，通常用于大型机
  MBCS/DBCS(Multi/Double -Byte Character Set) -- 多/双字节字符集，混合长度的字符集，有些字符由多个字节组成，
    Win9x使用，DBCS是MBCS的一种特殊类型(有些字符由两个字节组成，表示一个指定地区的符号，如 中日韩)
    在VC6中，MBCS总是意味着DBCS(它不支持超过两个字节的字符集)
注意：ANSI字符是有符号的(char)，MBCS字符是无符号的(unsigned char) -- ANSI字符的表达式取值和使用MBCS字符的不同

ATL字符串转换宏(如 T2W，T2BSTR 等)
  当源字符集和目的字符集不同并且目的类型不是BSTR时，会使用运行库函数 _alloca 在栈上分配内存，因此：
    1.不要在循环中使用
    2.当目的类型是BSTR时，会使用 SysAllocString 和 SysAllocStringLen 函数来分配目标字符串，必须使用 
      SysFreeString 显示地释放
  但 CT2W 等宏似乎没有这个问题了?
  ATL::ocscpy -- 拷贝 OLESTR 字符串，而不要用 lstrcpyW(Win9X上没有实现)， 对应的有 ocslen/CharNextO 等

多线程模型(向导)
  Apartment -- 无需同步对实例数据的访问就能保护对象，但这个类的对象可在不同的STA中被创建，所以静态和全局数据仍然需要同步。
  Free -- 这个类的对象只能存在于MTA中(如果没有，系统会自动创建一个，并自动同步？)在MTA中的对象必须同步对实例、全局数据的访问
  Both -- 希望共享客户套间的对象可把他们的类标记为Both，意味着没有不兼容的线程模型。当想避免代理/存根开销的时候可以使用这个值。

  实例数据的同步:对象级的锁(方便安全但并发性低) 和 细粒度的数据锁(允许高并发但需要小心使用防止死锁)
    CComCriticalSection -- 需要手动 Init/Term 的 CRITICAL_SECTION, Init->Lock->Unlock->Term
      用于需要一个全局或者静态的临界区，并且C运行库(CRT)不能自动完成构造和析构工作时（为什么会这样?不使用CRT?）
    CComAutoCriticalSection -- 构造中自动初始化，析构中自动终止， Lock->Unlock
    CComAutoDeleteCriticalSection -- 从 CComCriticalSection 继承，可以防止多次调用 Init/Term ?
    CComFakeCriticalSection -- 通常用于单线程模型时，避免锁定的开销
  自动的范围锁：CComObjectLockT<>，在 CComObjectRootEx 中typedef 为 ObjectLock，使用方法：ObjectLock lock(this);
    
CComObjectRootEx 提供恰好足够线程安全(just-safe-thread-enough)的对象生命周期管理和对象锁定功能。

CComXXXThreadModel -- 定义了静态的 Increment/Decrement，用于抽象出管理一个对象的生命周期计算器在单线程和多线程方式下的差异
  CComMultiThreadModelNoCS -- 引用计数时采用线程安全的方式，但不使用对象级锁(即没有除引用计数外需要保护的成员变量 或 使用细粒度的数据锁 ?)

服务器的“缺省”线程模型(为什么没有看到对应的宏), ATL 使用这些宏来typedef CComObjectThreadModel/CComGlobalsThreadModel，
  ATL在内部使用 CComObjectThreadModel 保护实例数据， CComGlobalsThreadModel 来保护全局和静态数据。
  为了保证程序运行正确，哪怕服务器中只有一个多线程类，也必须把向导生成德尔 _ATL_APARTMENT_THREADED 改为 _ATL_FREE_THREADED
  _ATL_SINGLE_THREADED
  _ATL_APARTMENT_THREADED  -- ftlConfigDetect.h 中有对其的判断
  _ATL_FREE_THREADED
  
MMC(Microsoft Management Console) -- 微软管理控制台。可以写 extensions(扩展) ?

IDispatch中对于TypeLib的手动实现(即 IDispatchImpl 的实现方式 ?)
  a.构造中从注册信息中获得 ITypeInfo指针的成员变量 m_pTypeInfo， 在IDispatch的方法实现中即可调用该接口实现
    IID*		pIID = &IID_IPenguin;
    GUID*		pLibID = &LIBID_BIRDSERVERLib;
    WORD		wMajor = 1;
    WORD		wMinor = 0;
    ITypeLib* pTl = NULL;
    HRESULT hr = LoadRegTypeLib(*pLibID, wMajor, wMinor, 0, &pTl);
    if(SUCCEEDED(hr))
    {  hr = pTl->GetTypeInfoOfGuid(*pIID, &m_pTypeInfo); pTl->Release(); }
  b.GetTypeInfoCount 函数返回 1;
  c.GetTypeInfo 中 
    { 
      if ctInfo != 0; { *ppti= NULL; return DISP_E_BADINDEX; }
      *ppti = m_pTypeInfo; m_pTypeInfo->AddRef(); return S_OK;
    }

自动化接口的建议
  1.不要在一个单独的实现中支持多个双接口
  2.不要把可重用的、多态的COM接口设计成双接口(即普通接口不要是双接口)
  3.如果想支持脚本客户，建议定义一个单独的双接口来暴露类的所有功能
    理由：脚本客户仅能获得缺省双接口的方法和属性
    
COM对象最好不要继承自多个IDispatch接口 -- 

CComObjectRootBase::InternalQueryInterface -- 静态函数，对于被请求的接口，用一个指向适当VPTR(virtual function table pointer虚函数表指针)
  的指针来填充参数 ppvObject 返回，

AVI Mux 中写入属性
   http://en.wikipedia.org/wiki/Resource_Interchange_File_Format
   http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/RIFF.html
 CComQIPtr<IPersistMediaPropertyBag> pPersist;
 CComPtr<IMediaPropertyBag> pBag;
 VARIANT val; 
 // Query the AVI Mux filter for IPersistMediaPropertyBag (not shown).
 pPersist = m_spMuxFilter;
 CoCreateInstance(CLSID_MediaPropertyBag, NULL, CLSCTX_INPROC, IID_IMediaPropertyBag, (LPVOID *)&pBag);
 val.vt = VT_BSTR;
 val.bstrVal = SysAllocString(OLESTR("MyProperty"));
 pBag->Write(OLESTR("INFO/IART"), &val);  //RIFFINFO_IART
 pPersist->Load(pBag, NULL);
 VariantClear(&val);
  
  
Implement Interface wizard(实现接口向导) -- 实现类型库(TypeLib)中已有定义的接口
连接点：为了使脚本客户(如IE)接收事件，对象需要从 IProvideClassInfo2Impl 继承，对应接口允许客户查询对象的
        缺省接口标识符(default interface identifier),然后用它通过 IConnectPointContainer 接口建立联系

IViewObjectExImpl -- 

不能使用CComBSTR代替BSTR的场景：？
CComVariant

UI
  向导生成的对话框从 CAxDialogImpl 派生,

组件类别(使用 BEGIN_CATEGORY_MAP/END_CATEGORY_MAP 声明 )
  CATID_SafeForScripting -- 安全脚本
  CATID_SafeForInitializing -- 安全初始化，有什么用？

docfileview http://blog.tinybrowser.net/archives/442
视频解码器和render之间增加一个内容透传的filter，需要处理颜色空间的差异及显卡内存自动对齐问题
  http://bbs.csdn.net/topics/340218555

http://wenku.baidu.com/view/6243ee2f2af90242a895e555.html

1.Intel Media SDK
  http://software.intel.com/en-us/articles/intel-media-software-development-kit-intel-media-sdk/
  支持 H.264 和 MPEG-2 格式编码,提供了 Encoder/Decoder Filter
  支持Intel显卡的硬编码
  授权协议： 免费，非开源
  问题：
     1.目前尚未测试通过(不能生成文件)， 需要进一步研究测试。
     2.发布时需要包含Intel Media SDK相关的文件(有一个 11.5M的 libmfxsw32.dll, 使用最高压缩比的ZIP压缩后为 3.6M)
  
2.Media Foundation
  http://msdn.microsoft.com/library/windows/desktop/dd757927(v=vs.85).aspx
  支持 H264 Video Encoder
  授权协议：Windows自带，但 需要 Windows 7 OS
  其他：Snagit 11 Video Record 在 Windows7 的实现似乎就是这种方式
  
  
	static const GUID CLSID_H264EncMs = 
	{ 0x6ca50344, 0x051a, 0x4ded, { 0x97, 0x79, 0xa4, 0x33, 0x05, 0x16, 0x5e, 0x35 } };

	CComPtr<IUnknown> spUnknown;
	COM_VERIFY(CoCreateInstance(CLSID_H264EncMs, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID*)&spUnknown));
	if (spUnknown)
	{
		COM_VERIFY(spUnknown->QueryInterface(IID_IMFTransform, (void**)&m_spTransformH264));
	}
	VIDEOINFOHEADER* pHeader = NULL;

	//{98230571-0087-4204-b020-3282538e57d3}
	static const GUID CLISD_ColorConvertDMO = 
	{ 0x98230571, 0x0087, 0x4204, { 0xb0, 0x20, 0x32, 0x82, 0x53, 0x8e, 0x57, 0xd3 } };
	CComPtr<IUnknown> spColorConvertDMO;
	COM_VERIFY(CoCreateInstance(CLISD_ColorConvertDMO, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID*)&spColorConvertDMO));
	if (spColorConvertDMO)
