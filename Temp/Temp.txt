TODO: 发邮件 COMStudy 比较

ATL 中对文件映射的封装：CAtlFileMapping
  #import <shdocvw.dll> exclude("OLECMDID", "OLECMDF") rename("FindText", "shFindText")
  

  
ATL 中调试宏 -- _ATL_DEBUG_INTERFACES ， 作用？

调试重载 Invoke 时: 
	//注意：pdispparams->rgvarg 的顺序和函数签名中参数的顺序是反着的，因此需要从后向前输出信息
	FTL::CFIExplorerDispidInfo IExplorerDispId(dispidMember);
	FTLTRACE(TEXT("%s:\n"), IExplorerDispId.GetConvertedInfo());
	for(UINT index = 0; index < pdispparams->cArgs ; index++) 
	{ 
		FTL::CFVariantInfo varInfo(pdispparams->rgvarg[pdispparams->cArgs - index - 1]);
		FTLTRACE(TEXT("\t %d, %s\n"), (index + 1), varInfo.GetConvertedInfo());
	}
    return __super::Invoke(xxxx);

浏览网页时的顺序：
  DISPID_ONVISIBLE(OnVisible)
  DISPID_BEFORENAVIGATE2(BeforeNavigate2)
  DISPID_DOWNLOADBEGIN(DownloadBegin)
  DISPID_COMMANDSTATECHANGE(CommandStateChange) -- 指示 Toolbar/Forward/Back 等按钮的状态改变
  DISPID_STATUSTEXTCHANGE(StatusTextChange) -- 状态条文本改变,如"检测代理、连接信息"等
  DISPID_PROGRESSCHANGE(ProgressChange) -- 进度改变
  DISPID_FILEDOWNLOAD(FileDownload) -- 指示开始下载文件，可以通过 bCancel 取消
  DISPID_DOWNLOADCOMPLETE(DownloadComplete) -- 浏览完成时（或挂起，失败时) -- 这个发生了两次，和 NavigateComplete2 的关系和顺序？
  DISPID_SETSECURELOCKICON(SetSecureLockIcon) -- 加密等级变化
  DISPID_TITLECHANGE(TitleChange) -- 标题改变
  DISPID_NAVIGATECOMPLETE2(NavigateComplete2) -- 导航结束(为什么没有发生 NavigateComplete?)
  DISPID_PROGRESSCHANGE(ProgressChange) -- 进度改变(ProgressMax/ProgressMax ，然后 -1/ProgressMax 表示完全结束 )
  DISPID_DOCUMENTCOMPLETE(DocumentComplete) -- 文档完全加载(一般在这个事件中进行后续处理), 
         Url 是规范化后的URL，也可能经过服务器重定位后的，在没有frame的页面中，加载完成后只触发一次，有多个frame时，每个frame均触发；
         highest frame 触发最终的事件，此时 pDisp 指向 highest frame。
  
客户区拖动：
  1.OnLButtonDown 中，SendMessage ( m_hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0 ); return 0;


WTL 中处理Web:
方法1:
CAxWindow::CreateControlEx("http://www.xxx", NULL, NULL, NULL, DIID_DWebBrowserEvents2, spUnknown) -- 即可创建 WebBrowser，且处理相关事件
           可通过 CAxWindow::QueryControl 获取对应的控件
                  CAxWindow::QueryHost 获取控件宿主(IAxWinAmbientDispatch)
方法2:
class CBrowserView : public CWindowImpl<CBrowserView, CAxWindow>, 
                     public IDispEventSimpleImpl<标识ID, CBrowserView, &DIID_DWebBrowserEvents2>
{
public:
  DECLARE_WND_SUPERCLASS(_T("TabBrowser_TabPageWindow"), CAxWindow::GetWndClassName())
}

IDispatchImpl <== 提供自动化/双接口的实现支持(IDispatch接口实现)

IDispEventSimpleImpl <== 事件处理的基本实现，但需要自己手工(重载 GetFuncInfoFromId 或 使用 SINK_ENTRY_INFO)提供函数的调用原型(SINK_INFO)
  <= IDispEventImpl <== 可以在定义类时指定对应的类型库(LibId和版本)，自动加载对应的Lib获得函数的调用原型，可以直接使用 SINK_ENTRY_EX/SINK_ENTRY
                        版本可用 AtlGetObjectSourceInterface 获得(有没有工具?)，然后对应构造

ISimpleEventImpl  -- 没有这个类?

ITypeInfo::Invoke是把DispID使用TypeLibrary中的接口定义，换算成虚函数的Index，然后通过虚函数表(Vtable)来直接调用接口的函数
ATL连接点客户端 "注意：不能直接用 AtlAdvise/AtlUnadvise"的理由：
  IDispEventImpl和IDispEventSimpleImpl这两个类并没有直接继承IDispatch，无法通过QueryInterface来直接获得对应事件回调接口,
  内部强制Cast到IUnknown（IDispEventSimpleImpl虽然不是从IUnknown继承，但定义了IUnknown和IDispatch的所有方法，VTable的布局一致）

两种方法(目前总结还不对)：
1.继承自:IDispEventImpl<标识ID, MyClassName, &DIID_DWebBrowserEvents2, &LIBID_SHDocVw, 1, 0>
  
2.继承自:IDispEventSimpleImpl,
  需要自己实现 GetFuncInfoFromId ?
IDispEventSimpleImpl<标识ID, MyClassName, &DIID_DWebBrowserEvents2> -- ATL中连接点的客户端(如处理WebBrowser的事件)
	//提供DISPID和函数实现的对应关系(表格)
	SINK_ENTRY_INFO -- 需要根据对应函数类型_ATL_FUNC_INFO类型的变量，如 
      __declspec(selectany) _ATL_FUNC_INFO CBrowserView::DocumentComplete2_Info = { CC_STDCALL, VT_EMPTY, 2, { VT_DISPATCH, VT_BYREF | VT_VARIANT } };
	SINK_ENTRY_EX -- 需要对应的 
	
	BEGIN_SINK_MAP ( MyClassName )
		SINK_ENTRY_INFO(标识ID, DIID_DWebBrowserEvents2, DISPID_DOCUMENTCOMPLETE, OnDocumentComplete, &DocumentComplete2_Info)
		SINK_ENTRY_EX ( 标识ID, DIID_DWebBrowserEvents2, DISPID_DOCUMENTCOMPLETE, OnDocumentComplete )
		SINK_ENTRY(标识ID, DISPID_DOCUMENTCOMPLETE, OnDocumentComplete)
	END_SINK_MAP()

// OnDocumentComplete 签名(签名可以通过 OleView 查看对应的 tlb 等文件
void __stdcall OnDocumentComplete ( IDispatch* pDispatch, VARIANT* /*pvUrl*/) ;


//IDispEventSimpleImpl 子类重载的方法，可以指定调用方式，默认是通过 AtlGetFuncInfoFromId 实现该功能
virtual HRESULT GetFuncInfoFromId ( const IID&, DISPID, LCID, _ATL_FUNC_INFO& )
{
	if ( !InlineIsEqualGUID ( iid, DIID_DWebBrowserEvents2 ) )
	{
		return E_FAIL ;
	}
	HRESULT hr = E_FAIL ;
	info.cc = CC_STDCALL ;
	switch ( dispid )
	{
		case DISPID_DOCUMENTCOMPLETE :
		{
			info.vtReturn = VT_EMPTY ;
			info.nParams = 2 ;
			info.pVarTypes[0] = VT_DISPATCH ;
			info.pVarTypes[1] = VT_VARIANT | VT_BYREF ;
			hr = S_OK ;
			break ;
		}
		default :
		{
			break ;
		}
	}
	return hr ;
}

atlcom.h 的 CComTypeInfoHolder::GetTI 中 "Module LIBID not initialized" 断言的原因：？？
AtlGetObjectSourceInterface(XXXXX) <== 获得默认类型信息，并存起来

GenericHTTPClient

	HINTERNET m_hOpen;				// internet open handle
	HINTERNET m_hConnection;		// internet connection hadle
	HINTERNET m_hRequest;		// internet request hadle
	
	BOOL bRet = ::InternetGetCookie(IDS_LOGIN_COOKIE_DOMAIN, NULL, szCookie, &len); 
	m_hOpen = ::InternetOpen(IDS_LOGIN_HTTP_AGENT, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0) ;
	m_hConnect = ::InternetConnect(m_hOpen, IDS_BLOG_UPLOAD_URL, 80, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
	m_hRequest = ::HttpOpenRequest(m_hConnect, _T("POST"), IDS_BLOG_UPLOAD_PAGE_URL + strID, NULL, NULL, NULL,
								   INTERNET_FLAG_NO_CACHE_WRITE | INTERNET_FLAG_RELOAD, 0);
	
	//获取参数列表(比如 Content-Type、Accept、Content-Length、 User-Agent、Connection、Cookie 等)，循环发送出去?
	//  参数类型: 参数值
	while(...)
	{
		bRet = ::HttpAddRequestHeaders(m_hRequest, strHeader.GetBuffer(), strHeader.GetLength(), HTTP_ADDREQ_FLAG_ADD_IF_NEW);

	}

	INTERNET_BUFFERS InternetBufferIn = {0};
	InternetBufferIn.dwStructSize = sizeof(INTERNET_BUFFERS);
	InternetBufferIn.Next = NULL;

	bRet = ::HttpSendRequestEx(m_hRequest, &InternetBufferIn, NULL, HSR_INITIATE, 0);

	//循环 发送数据
	while(...)
	{
		DWORD dwOutPostBufferLength = 0;
		bRet = ::InternetWriteFile(m_hRequest, buffToPost.GetCurrentBuffer(), nBufferSize, &dwOutPostBufferLength);
	}
	
	bRet = ::HttpEndRequest(m_hRequest, NULL, HSR_INITIATE, 0);

	//获取结果
	const int RESPONSE_MAX_LENGTH = 1024;
	char byData[RESPONSE_MAX_LENGTH + 1];
	DWORD dwReadByte = 0;
	BOOL bRetVal = ::InternetReadFile(m_hRequest, byData, RESPONSE_MAX_LENGTH, &dwReadByte) ;

http://hi.baidu.com/xlrtx/blog/item/12c312332d07f8f01a4cff8b.html

协议 -- 三部分组成：协议头，具体内容以及协议尾， 必须是ASCII格式？
  协议类型：
  使用多个表单项（同时传?）传递数据(HTTP POST-MultiPartFormData)
    1. 使用 "Content-Type: multipart/form-data; boundary=--XXXXXXXXXXXX" 声明使用多表单分，且指定分割符号
       (可自定义，但一般使用的是 --MULTI-PARTS-FORM-DATA-BOUNDARY )
    2. 多个部分内容，有 Content-Disposition 和 Content-Type， 如(参数信息、二进制原始信息)，
       每一部分用 --{boundary} 分开(注意前面多两个 "--" )
    3. 使用 --{boundary}-- 表示结束(注意前后各多两个 "--" )
    
ffmpeg -- 开源且跨平台的音视频解决方案，是一套编解码的框架，具有采集、解码、流化等功能（http://www.ffmpeg.org/）
   模块
     ffmpeg -i 输入文件 输出文件 -- 视频文件转换命令行工具,也支持经过实时电视卡抓取和编码成视频文件
     ffserver -- 基于HTTP(RTSP正在开发中)用于实时广播的多媒体服务器.也支持时间平移 
     ffplay -- 用 SDL和FFmpeg库开发的一个简单的媒体播放器(需要先安装 SDL 库才能编译)
     libavcodec -- 包含了所有FFmpeg音视频编解码器的库.为了保证最优性能和高可复用性,大多数编解码器从头开发的
     libavformat -- 包含了所有的普通音视格式的解析器和产生器的库
     
  无法使用VC编译(实际上可以？)，只能用MSys+MinGW编译，但是编译出来的DLL是可以被VC使用的
     http://www.cnblogs.com/mcodec/articles/1659671.html -- 使用VC编译的方法
     http://ffmpeg.zeranoe.com/blog/  -- 自动下载和编译ffmpeg的脚本
  ./configure --enable-shared --disable-static --enable-memalign-hack --disable-yasm
     --enable-shared      编译动态库
     --disable-static     禁用静态库
     --enable-memalign-hack     启用内存对其，Windows下必须
     --enable-libx264     使用x264作为h264编码器,表示要使用第3方库x264,此时mingw include 和 lib内必须已经有x264.h和libx264.a
     --enable-libmp3lame     使用mp3lame作为mp3编码器（http://sourceforge.net/projects/lame/files/）
     --enable-gpl      遵循gpl协议,必须指定，因为x264是gpl协议
     --disable-debug   禁用调试信息
     --enable-small    启用文件最小功能
     
   编解码库（ffmpeg 只是一个框架，不同的编解码库在不同的网站？http://ffmpeg.zeranoe.com/builds/），
     可通过 --extra-cflags 来指定头文件的文件夹?
     libx264 
     libfaac 
     libmp3lame -- linux 下支持mp3
     libogg 
     libspeex 
     libvorbis 
     libtheora  
     
   源码分析
     Demuxer -- 媒体格式解码器
     struct AVCodec -- codec 的数据结构，全局变量 *first_avcodec, avcodec_register_all 方法注册全部 codec
     解码播放：Media -> ByteIOContext -> Demuxer -> Decode -> YUV -> Display
     格式转换：Media -> ByteIOContext -> Demuxer -> Decode -> YUV -> Encode -> Muxer -> ByteIOContex -> Media
       格式转换，如 文件类型从 .flv -> mp4
       编码类型，如 codec 从 mpeg4 -> H264
     媒体录制：YUV -> Encode -> Muxer -> ByteIOContex -> Media
       
Firefox
  两种扩展方式
  1.插件（Plugins/Plug-ins) -- 让Firefox能够显示特殊格式的文件而由相应的第三方应用程序提供的二进制文件
    (如显示Flash的Adobe shockwave flash等)
  2.扩展（extensions）-- 修改或者增强Firefox本身的功能而提供的一种打包格式,通常由包含功能代码的js脚本、包含界面的xul
    文件以及包含皮肤的css文件和各种图像文件组成。扩展名xpi的zip压缩包。

https://developer.mozilla.org/en-US/docs/Code_snippets
XPCOM(Cross Platform Component Object Module) -- 跨平台组件对象模型，仿MS 的 COM实现
调试(使用helloworld测试通过, http://kb.mozillazine.org/Getting_started_with_extension_development , 搜索 "download" ):
  1.安装的扩展的路径: %USERPROFILE%\Application Data\Mozilla\Firefox\Profiles\<profile_id>.default\extensions\
    Win7 -- C:\Users\user\AppData\Roaming\Mozilla\Firefox\Profiles\XXXX\extensions\
  2.创建一个新的文本文件，用扩展ID做为文件名来保存文件，没有文件扩展名。如果使用ID是GUID值，那么文件名也必须包含‘{}’。
  3.文本文件中输入开发目录的全路径(如：c:\extensions\my_extension\)，路径必须以‘\’结尾并且之后不能有空格。
  4.启动Firefox，Firefox将检测到文本链接扩展目录，并安装扩展。这种方法的优点就是修改了代码后，重启Firefox可以立即生效，不必打包压缩XPI文件。
  
扩展(产品的策略：只支持最近的3个版本) -- firefox extension tutorial
  1.早期的基于JavaScript和XUL的方式： FF->JS->XpCom->C++ Dll
    JavaScript -- FF内核调用编译性程序的粘和剂，完成业务逻辑，通过它来调用编译性的程序（比如c++的动态库，API）
    XUL，应用XML来描述使用者界面的标示语言，完成UI定制
    CSS -- xul和css配合表示界面
  2.FF4 以后 add on builder 和 add on sdk  的方式, 就是XPCOM?
    XPCOM -- Mozilla构建的跨平台组件结构，原理类似于微软的Com组件。编译性的，提供主要的逻辑处理。
             目前Mozilla 已不想支持XPCom， 从firefox4.0开始，每个版本的firefox 有一套自己的SDK。
             XPCOM 并不直接支持 C++ 的异常处理. 在 XPCOM 中, 所有的异常必须在组件内部处理, 而不能跨越接口的边界，返回 nsresult(类似 HRESULT)
             契约 ID(类似ProgID?) -- 用于访问组件的可读(to humen)的字符串
             XPCOM 的 组件管理器 ?
       refp = do_CreateInstance( "@mozilla.org/accessibleRetrieval;1", &rv);
       智能指针：nsCOMPtr、nsAutoPtr、nsAutoArrayPtr、nsRefPtr
       服务：nsCOMPtr<nsIPrefService> prefService = do_GetService (NS_PREFSERVICE_CONTRACTID);
         写跨平台组件所需要的其他服务
           跨平台文件抽象：向 XPCOM 开发人员提供同一而强大的文件访问功能.
           目录服务, 提供应用和特定系统定位信息.
           内存管理, 保证所有对象使用同样的内存分配器. 
           事件通知机制, 允许传递简单消息.
       nsIServiceManager -- 
       编译 idl 的工具是 xpidl.exe,
         -I 目录 包含系统或第三方idl的目录
         -m typelib 生成以 .xpt 为后缀的类型库，类型库可以通过XPConnect向类似JavaScript的语言提供组件访问的Wrapper
         -m header 生成头文件
            
    Gecko -- 一个开源的, 遵循标准的, 嵌入式 web 浏览器和 工具包.
    Gecko SDK(XulRunner SDK)9.0.1 -- https://developer.mozilla.org/en/Gecko_SDK
                                https://developer.mozilla.org/en/XPCOM/XPCOM_changes_in_Gecko_2.0
                                https://developer.mozilla.org/en/How_to_build_a_binary_XPCOM_component_using_Visual_Studio

      nsISupports -- 基础接口，类似 IUnknown
     
      
    Python -- 
       从 idl 生成头文件 -- header.py -I  yourGecokSDKfolder \idl -o yourheader.h youridl.idl".
       从 idl 生成 typelib(.xpt) -- typelib.py -I  yourGecokSDKfolder \idl -o yourtypelib.xpt youridl.idl
    
    
通过js-ctypes在addon中直接调用dll中的函数，参考URL： https://developer.mozilla.org/en/js-ctypes/Using_js-ctypes

开发工具：aptana
There is an extension name XPComViewer which could check if your XPCom register to FF.
几个帮助开发的扩展，分别是 Venkman、Extension Developer's Extension 、Console2 、Chrome List 和 Firebug。

Firefox 把用户的个人信息，包括设置、已安装的扩展等，都保存在一个概要文件中，默认是使用名为 default 的概要文件。
通过创建一个专门为开发使用的概要文件，可以不影响正常的使用，也不会破坏个人信息。为了创建另外一个概要文件，
运行 firefox CP，在弹出的“选择概要文件”的对话框中，新建一个名为 dev 的概要文件，并使用此概要文件来运行 Firefox。
在地址栏输入 about:config 可以打开 Firefox 的参数设置页面
  javascript.options.showInConsole = true //把 JavaScript 的出错信息显示在错误控制台
  nglayout.debug.disable_xul_cache = true //禁用 XUL 缓存，使得对窗口和对话框的修改不需要重新加载 XUL 文件
  browser.dom.window.dump.enabled　= true //允许使用 dump() 语句向标准控制台输出信息
  javascript.options.strict　　　　= true //在错误控制台中启用严格的 JavaScript 警告信息
当需要进行扩展开发时，运行 firefox -P dev 启动 Firefox 即可

在扩展中可以使用覆盖（Overlay）来向已有的界面中添加元素(如系统 Tools菜单 <menupopup id="menu_ToolsPopup"> )

扩展的基本目录结构
  chrome.manifest -- Chrome 注册的清单文件,
  install.rdf -- 包含了扩展安装的信息
  [chrome] -- Chrome指的是应用程序窗口的内容区域之外的用户界面元素的集合，
      这些用户界面元素包括工具条，菜单，进度条和窗口的标题栏等。三种基本的chrome提供者
    [content] -- 扩展的描述界面的 XUL 文件和增加行为的 JavaScript 文件。
    [locale] -- 存放的是本地化相关的文件, 如  en-US、zh-CN、ko-KR、vi-VN 目录
    [skin] -- 存放CSS 文件，用来定义扩展的外观
  [components]
  [defaults]
  
JS -- 调用: SomeClass.someFun();
  var SomeClass = { 
    someFun : function( param1, param2 ) {
      var ....
    }
  }；

  //打开一个新的窗口，或是使得已经创建的窗口获得焦点
　openWindow : function(windowName, url, flags, params) {
　　var windowsMediator = Components.classes["@mozilla.org/appshell/window-mediator;1"]
　　　.getService(Components.interfaces.nsIWindowMediator);
　　var aWindow = windowsMediator.getMostRecentWindow(windowName);
　　if (aWindow) {
　　　aWindow.focus();
　　}　　　
　　else {
　　　aWindow = window.openDialog(url, windowName, flags, params);
　　}
　　return aWindow;
　}
　
UAC Elevation
实际上一个软件在用不同的模块运行，因Virtualization映射到其他位置的Data文件，所以在操作磁盘文件以及注册表的时候，实际上是一个软件在用不同的模块运行。

Win8
  两种不同的用户接口，需要分别运行不同类型的应用程序（如IE有对应的 Metro style 和 Desktop style)
    经典 -- 桌面应用程序
    Metro -- 专门的 Metro 程序或 Metro-style enabled desktop browsers (MEDB).
              Metro模式下的IE只有Flash插件，不能安装或运行其他的任何插件?
  WinRT -- ARM平台上的Window8，只能运行纯粹的Metro程序，不能使用Win32API，需要使用专门的 WinRT API?
  
  Enhanced Protected Mode(EPM)-- 启用后很多插件都无法正确运行。Metro类型的始终运行于EPM, Desktop类型的可选(Internet Options->Advanced),
  Web网站的开发者在 Http Header 中通过"X-UA-Compatible:requiresActiveX=true" 选项要求plugin(即要求经典模式?)